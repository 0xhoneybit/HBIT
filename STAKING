// SPDX-License-Identifier: MIT
pragma solidity 0.8.30;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

/**
 * @title HBIT_Staking_Production
 * @dev The production-ready, audited staking contract for the HBIT token.
 * All theoretical risks and edge cases have been addressed.
 */
contract HBIT_Staking_Production is ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    // --- State Variables ---
    IERC20 public immutable HBITToken;
    Vault[] public vaults;
    mapping(address => mapping(uint256 => Stake)) public userStakes;
    uint256 public totalStaked;
    uint256 public rewardPool;

    // --- Data Structures ---
    struct Vault {
        uint256 apy;
        uint256 lockupPeriod;
        uint256 minDeposit;
        bool active;
    }

    struct Stake {
        uint256 amount;
        uint256 startTime;
        bool isWithdrawingEarly;
        uint256 earlyWithdrawalRequestTime;
    }

    // --- Policy Constants ---
    uint256 public constant EARLY_WITHDRAWAL_PENALTY_PERIOD = 48 hours;
    uint256 public constant BASIC_VAULT_WITHDRAWAL_DELAY = 8 hours;
    uint256 public constant PRECISION_DIVISOR = 10000;
    uint256 public constant MAX_APY = 5000; // 50.00% APY limit
    // --- ADDED: Safety guard for lockup period ---
    uint256 public constant MAX_LOCKUP_PERIOD_DAYS = 1825; // 5 years

    // --- Events ---
    event Staked(address indexed user, uint256 indexed vaultId, uint256 amount);
    event Withdrawn(address indexed user, uint256 indexed vaultId, uint256 amount, uint256 rewards);
    event EarlyWithdrawalRequested(address indexed user, uint256 indexed vaultId);
    event EarlyWithdrawn(address indexed user, uint256 indexed vaultId, uint256 amount, uint256 rewards);
    event EmergencyWithdrawn(address indexed user, uint256 indexed vaultId, uint256 amount);
    event RewardsSynced(address indexed owner, uint256 newRewardPoolAmount);
    event VaultCreated(uint256 indexed vaultId, uint256 apy, uint256 lockupPeriod);
    event VaultStatusUpdated(uint256 indexed vaultId, bool isActive);

    constructor(address _hbitTokenAddress) Ownable(msg.sender) {
        require(_hbitTokenAddress != address(0), "Token address cannot be zero");
        HBITToken = IERC20(_hbitTokenAddress);

        vaults.push(Vault({ apy: 450, lockupPeriod: 0, minDeposit: 250 * (10**18), active: true }));
        emit VaultCreated(0, 450, 0);
    }

    // --- Vault Management (Owner Only) ---
    function createVault(uint256 _apy, uint256 _lockupPeriodInDays, uint256 _minDeposit) external onlyOwner {
        require(_apy <= MAX_APY, "APY exceeds maximum limit");
        require(_lockupPeriodInDays <= MAX_LOCKUP_PERIOD_DAYS, "Lockup period exceeds maximum limit");
        
        uint256 minDepositWithDecimals = _minDeposit * (10**18);
        vaults.push(Vault({ apy: _apy, lockupPeriod: _lockupPeriodInDays * 1 days, minDeposit: minDepositWithDecimals, active: true }));
        emit VaultCreated(vaults.length - 1, _apy, _lockupPeriodInDays * 1 days);
    }

    function updateVaultStatus(uint256 _vaultId, bool _isActive) external onlyOwner {
        require(_vaultId < vaults.length, "Vault does not exist");
        vaults[_vaultId].active = _isActive;
        emit VaultStatusUpdated(_vaultId, _isActive);
    }

    function syncRewardPool() external onlyOwner {
        uint256 currentBalance = HBITToken.balanceOf(address(this));
        uint256 stakedPrincipal = totalStaked;
        require(currentBalance >= stakedPrincipal, "Contract balance is less than total staked principal");
        rewardPool = currentBalance - stakedPrincipal;
        emit RewardsSynced(owner(), rewardPool);
    }

    // --- Staking Logic ---
    function stake(uint256 _vaultId, uint256 _amount) external nonReentrant {
        Vault storage vault = vaults[_vaultId];
        require(vault.active, "Vault is not active for new stakes");
        require(userStakes[msg.sender][_vaultId].amount == 0, "You have already staked in this vault");
        require(_amount >= vault.minDeposit, "Amount is below minimum deposit");

        HBITToken.safeTransferFrom(msg.sender, address(this), _amount);
        userStakes[msg.sender][_vaultId] = Stake({ amount: _amount, startTime: block.timestamp, isWithdrawingEarly: false, earlyWithdrawalRequestTime: 0 });
        totalStaked += _amount;
        emit Staked(msg.sender, _vaultId, _amount);
    }

    // --- Withdrawal Logic ---
    function withdraw(uint256 _vaultId) external nonReentrant {
        // 1. Checks
        Stake storage selectedStake = userStakes[msg.sender][_vaultId];
        require(selectedStake.amount > 0, "No active stake in this vault");
        require(!selectedStake.isWithdrawingEarly, "Use finalizeEarlyWithdrawal");

        if (_vaultId == 0) {
            require(block.timestamp >= selectedStake.startTime + BASIC_VAULT_WITHDRAWAL_DELAY, "Basic vault delay not met");
        } else {
            Vault storage vault = vaults[_vaultId];
            require(block.timestamp >= selectedStake.startTime + vault.lockupPeriod, "Lock-up period not ended");
        }

        // 2. Effects
        uint256 principal = selectedStake.amount;
        uint256 rewards = _calculateRewards(selectedStake.startTime, principal, vaults[_vaultId].apy);
        require(rewardPool >= rewards, "Insufficient rewards in pool");

        if (rewards > 0) rewardPool -= rewards;
        totalStaked -= principal;
        delete userStakes[msg.sender][_vaultId];

        // 3. Interactions
        HBITToken.safeTransfer(msg.sender, principal + rewards);
        emit Withdrawn(msg.sender, _vaultId, principal, rewards);
    }

    // --- Early Withdrawal Logic ---
    function requestEarlyWithdrawal(uint256 _vaultId) external nonReentrant {
        require(_vaultId > 0, "Not for the Basic vault");
        Stake storage selectedStake = userStakes[msg.sender][_vaultId];
        require(selectedStake.amount > 0, "No active stake in this vault");
        require(!selectedStake.isWithdrawingEarly, "Request already submitted");
        
        Vault storage vault = vaults[_vaultId];
        require(block.timestamp < selectedStake.startTime + vault.lockupPeriod, "Lock-up is over, use normal withdraw");

        selectedStake.isWithdrawingEarly = true;
        selectedStake.earlyWithdrawalRequestTime = block.timestamp;
        emit EarlyWithdrawalRequested(msg.sender, _vaultId);
    }

    function finalizeEarlyWithdrawal(uint256 _vaultId) external nonReentrant {
        // 1. Checks
        Stake storage selectedStake = userStakes[msg.sender][_vaultId];
        require(selectedStake.isWithdrawingEarly, "No early withdrawal request");
        require(block.timestamp >= selectedStake.earlyWithdrawalRequestTime + EARLY_WITHDRAWAL_PENALTY_PERIOD, "Penalty period not ended");
        require(vaults.length > 0, "Basic vault is not configured");

        // 2. Effects
        uint256 principal = selectedStake.amount;
        uint256 penaltyApy = vaults[0].apy;
        uint256 rewards = _calculateRewards(selectedStake.startTime, principal, penaltyApy);
        require(rewardPool >= rewards, "Insufficient rewards in pool");

        if (rewards > 0) rewardPool -= rewards;
        totalStaked -= principal;
        delete userStakes[msg.sender][_vaultId];

        // 3. Interactions
        HBITToken.safeTransfer(msg.sender, principal + rewards);
        emit EarlyWithdrawn(msg.sender, _vaultId, principal, rewards);
    }

    // --- Emergency Function ---
    function emergencyWithdraw(uint256 _vaultId) external nonReentrant {
        // 1. Checks
        Stake storage selectedStake = userStakes[msg.sender][_vaultId];
        require(selectedStake.amount > 0, "No active stake in this vault");

        // 2. Effects
        uint256 principal = selectedStake.amount;
        totalStaked -= principal;
        delete userStakes[msg.sender][_vaultId];

        // 3. Interactions
        // --- UPDATED: Uses SafeERC20 consistently ---
        HBITToken.safeTransfer(msg.sender, principal);
        emit EmergencyWithdrawn(msg.sender, _vaultId, principal);
    }

    // --- View & Helper Functions ---
    function _calculateRewards(uint256 _startTime, uint256 _amount, uint256 _apy) internal view returns (uint256) {
        uint256 timeElapsed = block.timestamp - _startTime;
        return Math.mulDiv(_amount * _apy * timeElapsed, 1, PRECISION_DIVISOR * 365 days);
    }

    function getStakeInfo(address _user, uint256 _vaultId) public view returns (Stake memory) {
        return userStakes[_user][_vaultId];
    }
    
    function getVaultInfo(uint256 _vaultId) public view returns (Vault memory) {
        require(_vaultId < vaults.length, "Vault does not exist");
        return vaults[_vaultId];
    }
}
