// SPDX-License-Identifier: MIT
pragma solidity 0.8.30;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";

// Band Protocol 오라클 인터페이스
interface IBandPriceOracle {
    function getReferenceData(
        string calldata _base,
        string calldata _quote
    ) external view returns (
        uint256 rate,
        uint256 lastUpdatedBase,
        uint256 lastUpdatedQuote
    );
}

// TWAP 오라클 인터페이스
interface ITWAPOracle {
    function consult(address token, uint256 period) external view returns (uint256 price);
}

contract HBITPresale is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    // 총 판매 가능 HBIT량 (105,000,000 HBIT * 1e18)
    uint256 public constant TOTAL_HBIT_FOR_SALE = 105_000_000 * 1e18;
    uint256 public hbitDeposited;

    // 구매 금액 제한 ($50 ~ $10,000)
    uint256 public constant MIN_PURCHASE_USD = 50e18;
    uint256 public constant MAX_PURCHASE_USD = 10000e18;
    uint256 public constant MAX_PURCHASE_PER_USER = 10000e18;

    // 사용자별 누적 구매금액 추적
    mapping(address => uint256) public userTotalContributions;

    // 상태 관리
    enum State { Inactive, Active, Succeeded, Failed }
    State public currentState;

    // 시간 설정
    uint256 public constant SALE_START_TIME = 1759296000;
    uint256 public constant SALE_END_TIME = 1770326400;

    // ✅ 수정: 주소 타입은 immutable 유지 (가스 효율성)
    IERC20 public immutable HBIT_TOKEN;
    IERC20 public immutable USDT_TOKEN;
    AggregatorV3Interface public immutable chainlinkOracle;
    AggregatorV3Interface public immutable usdtUsdOracle;
    ITWAPOracle public immutable twapOracle;
    IBandPriceOracle public immutable bandOracle;

    // ✅ 수정: string → bytes32로 변경하여 immutable 사용 가능
    bytes32 public immutable BAND_BASE_SYMBOL;
    bytes32 public immutable BAND_QUOTE_SYMBOL;

    // 판매 설정
    uint256 public constant HBIT_PRICE_USD = 0.02e18;
    uint256 public constant HARD_CAP_USD = 2100000e18;
    uint256 public constant SOFT_CAP_USD = 840000e18;
    uint256 public constant MAX_PRICE_DEVIATION = 5e16;
    uint256 public constant TWAP_PERIOD = 3600;
    uint256 public constant ORACLE_STALE_THRESHOLD = 1 hours;

    // 데이터 저장소
    uint256 public totalUsdRaised;
    uint256 public totalBnbRaised;
    mapping(address => uint256) public contributionsBnb;
    mapping(address => uint256) public contributionsUsdt;
    mapping(address => uint256) public lockedUsdValue;

    // 이벤트
    event PurchaseBNB(address indexed buyer, uint256 bnbAmount, uint256 usdValue, uint256 hbitAmount);
    event PurchaseUSDT(address indexed buyer, uint256 usdtAmount, uint256 usdValue, uint256 hbitAmount);
    event ClaimTokens(address indexed user, uint256 hbitAmount);
    event ClaimRefund(address indexed user, uint256 amount);
    event Withdraw(address indexed recipient, uint256 bnbAmount, uint256 usdtAmount);
    event OracleDeviationExceeded(uint256 chainlinkPrice, uint256 twapPrice, uint256 bandPrice);
    event PresaleEnded(bool isSuccess);
    event HBITDeposited(address indexed depositor, uint256 amount);

    // ✅ 수정: bytes32 파라미터 추가
    constructor(
        address _hbitToken,
        address _usdtToken,
        address _chainlinkOracle,
        address _usdtUsdOracle,
        address _twapOracle,
        address _bandOracle,
        string memory _bandBaseSymbol,  // string으로 입력받지만
        string memory _bandQuoteSymbol  // 내부적으로 bytes32로 변환
    ) Ownable(msg.sender) {
        require(_hbitToken != address(0), "Invalid HBIT token");
        require(_usdtToken != address(0), "Invalid USDT token");
        require(_chainlinkOracle != address(0), "Invalid Chainlink oracle");
        require(_usdtUsdOracle != address(0), "Invalid USDT/USD oracle");
        require(_twapOracle != address(0), "Invalid TWAP oracle");
        require(_bandOracle != address(0), "Invalid Band oracle");

        // ✅ immutable 주소 타입 초기화
        HBIT_TOKEN = IERC20(_hbitToken);
        USDT_TOKEN = IERC20(_usdtToken);
        chainlinkOracle = AggregatorV3Interface(_chainlinkOracle);
        usdtUsdOracle = AggregatorV3Interface(_usdtUsdOracle);
        twapOracle = ITWAPOracle(_twapOracle);
        bandOracle = IBandPriceOracle(_bandOracle);

        // ✅ string → bytes32 변환하여 immutable 저장
        BAND_BASE_SYMBOL = bytes32(bytes(_bandBaseSymbol));
        BAND_QUOTE_SYMBOL = bytes32(bytes(_bandQuoteSymbol));

        currentState = State.Inactive;
    }

    // 관리자 기능
    function startPresale() external onlyOwner {
        require(block.timestamp >= SALE_START_TIME, "Presale not started yet");
        require(block.timestamp <= SALE_END_TIME, "Presale already ended");
        currentState = State.Active;
    }

    function endPresale() external onlyOwner {
        require(currentState == State.Active, "Presale not active");
        require(block.timestamp >= SALE_END_TIME, "Presale period not ended");

        bool isSuccess = totalUsdRaised >= SOFT_CAP_USD;
        currentState = isSuccess ? State.Succeeded : State.Failed;
        emit PresaleEnded(isSuccess);
    }

    // BNB 구매 (구매 제한 적용)
    receive() external payable {
        require(msg.value > 0, "Zero BNB amount");
        require(currentState == State.Active, "Presale not active");
        require(block.timestamp >= SALE_START_TIME && block.timestamp <= SALE_END_TIME, "Presale period ended");

        uint256 usdValue = _getVerifiedUsdValueFromBnb(msg.value);
        require(usdValue > 0, "Invalid USD value");

        // 구매 금액 제한 검증
        require(usdValue >= MIN_PURCHASE_USD, "Below minimum purchase");
        require(usdValue <= MAX_PURCHASE_USD, "Above maximum purchase per transaction");
        require(userTotalContributions[msg.sender] + usdValue <= MAX_PURCHASE_PER_USER, "Exceeded user purchase limit");

        uint256 hbitAmount = (usdValue * 1e18) / HBIT_PRICE_USD;
        require(totalUsdRaised + usdValue <= HARD_CAP_USD, "Hard cap exceeded");
        require(hbitDeposited + hbitAmount <= TOTAL_HBIT_FOR_SALE, "Insufficient HBIT supply");

        contributionsBnb[msg.sender] += msg.value;
        lockedUsdValue[msg.sender] += usdValue;
        userTotalContributions[msg.sender] += usdValue;
        totalUsdRaised += usdValue;
        totalBnbRaised += msg.value;

        emit PurchaseBNB(msg.sender, msg.value, usdValue, hbitAmount);
    }

    // purchaseWithBNB (구매 제한 적용)
    function purchaseWithBNB(uint256 minHbitAmount) external payable nonReentrant {
        require(msg.value > 0, "Zero BNB amount");
        require(currentState == State.Active, "Presale not active");
        require(block.timestamp >= SALE_START_TIME && block.timestamp <= SALE_END_TIME, "Presale period ended");

        uint256 usdValue = _getVerifiedUsdValueFromBnb(msg.value);
        require(usdValue > 0, "Invalid USD value");

        // 구매 금액 제한 검증
        require(usdValue >= MIN_PURCHASE_USD, "Below minimum purchase");
        require(usdValue <= MAX_PURCHASE_USD, "Above maximum purchase per transaction");
        require(userTotalContributions[msg.sender] + usdValue <= MAX_PURCHASE_PER_USER, "Exceeded user purchase limit");

        uint256 hbitAmount = (usdValue * 1e18) / HBIT_PRICE_USD;
        require(hbitAmount >= minHbitAmount, "Insufficient HBIT amount");
        require(totalUsdRaised + usdValue <= HARD_CAP_USD, "Hard cap exceeded");
        require(hbitDeposited + hbitAmount <= TOTAL_HBIT_FOR_SALE, "Insufficient HBIT supply");

        contributionsBnb[msg.sender] += msg.value;
        lockedUsdValue[msg.sender] += usdValue;
        userTotalContributions[msg.sender] += usdValue;
        totalUsdRaised += usdValue;
        totalBnbRaised += msg.value;

        emit PurchaseBNB(msg.sender, msg.value, usdValue, hbitAmount);
    }

    // purchaseWithUSDT (구매 제한 적용)
    function purchaseWithUSDT(
        uint256 amount,
        uint256 minHbitAmount,
        uint256 maxUsdAmount
    ) external nonReentrant {
        require(amount > 0, "Zero USDT amount");
        require(currentState == State.Active, "Presale not active");
        require(block.timestamp >= SALE_START_TIME && block.timestamp <= SALE_END_TIME, "Presale period ended");
        require(maxUsdAmount > 0, "Invalid max USD");

        uint256 usdValue = _getVerifiedUsdValueFromUSDT(amount);
        require(usdValue <= maxUsdAmount, "USD slippage exceeded");

        // 구매 금액 제한 검증
        require(usdValue >= MIN_PURCHASE_USD, "Below minimum purchase");
        require(usdValue <= MAX_PURCHASE_USD, "Above maximum purchase per transaction");
        require(userTotalContributions[msg.sender] + usdValue <= MAX_PURCHASE_PER_USER, "Exceeded user purchase limit");

        USDT_TOKEN.safeTransferFrom(msg.sender, address(this), amount);

        uint256 hbitAmount = (usdValue * 1e18) / HBIT_PRICE_USD;
        require(hbitAmount >= minHbitAmount, "Insufficient HBIT amount");
        require(totalUsdRaised + usdValue <= HARD_CAP_USD, "Hard cap exceeded");
        require(hbitDeposited + hbitAmount <= TOTAL_HBIT_FOR_SALE, "Insufficient HBIT supply");

        contributionsUsdt[msg.sender] += amount;
        lockedUsdValue[msg.sender] += usdValue;
        userTotalContributions[msg.sender] += usdValue;
        totalUsdRaised += usdValue;

        emit PurchaseUSDT(msg.sender, amount, usdValue, hbitAmount);
    }

    /**
     * USDT를 USD로 안전하게 변환 (USDT/USD 오라클 사용)
     */
    function _getVerifiedUsdValueFromUSDT(uint256 usdtAmount) internal view returns (uint256) {
        (, int256 usdtUsdPrice, , uint256 usdtUsdUpdatedAt, ) = usdtUsdOracle.latestRoundData();
        require(usdtUsdUpdatedAt > 0, "USDT/USD oracle stale");
        require(block.timestamp - usdtUsdUpdatedAt < ORACLE_STALE_THRESHOLD, "USDT/USD oracle too old");
        require(usdtUsdPrice > 0, "Invalid USDT/USD price");
        return (usdtAmount * uint256(usdtUsdPrice)) / 1e8;
    }

    /**
     * ✅ 수정: Band Protocol 호출 시 bytes32 → string 변환
     */
    function _getVerifiedUsdValueFromBnb(uint256 bnbAmount) internal view returns (uint256) {
        // Chainlink 가격
        (, int256 chainlinkPrice, , uint256 chainlinkUpdatedAt, ) = chainlinkOracle.latestRoundData();
        require(chainlinkUpdatedAt > 0, "Chainlink data stale");
        require(block.timestamp - chainlinkUpdatedAt < ORACLE_STALE_THRESHOLD, "Chainlink data too old");
        require(chainlinkPrice > 0, "Invalid Chainlink price");
        uint256 chainlinkUsdValue = (uint256(chainlinkPrice) * bnbAmount) / 1e8;

        // ✅ bytes32 → string 변환하여 Band Protocol 호출
        (uint256 bandPrice, uint256 bandLastUpdated, ) = bandOracle.getReferenceData(
            string(abi.encodePacked(BAND_BASE_SYMBOL)),  // bytes32 → string 변환
            string(abi.encodePacked(BAND_QUOTE_SYMBOL))  // bytes32 → string 변환
        );
        require(bandPrice > 0, "Invalid Band price");
        require(block.timestamp - bandLastUpdated < ORACLE_STALE_THRESHOLD, "Band data too old");
        uint256 bandUsdValue = (bandPrice * bnbAmount) / 1e18;

        // 가격 편차 검증
        require(
            _arePricesWithinDeviation(chainlinkUsdValue, bandUsdValue, MAX_PRICE_DEVIATION),
            "Oracle deviation too high"
        );

        return (chainlinkUsdValue * 60 + bandUsdValue * 40) / 100;
    }

    /**
     * 두 가격 간 편차가 허용 범위 이내인지 확인
     */
    function _arePricesWithinDeviation(
        uint256 price1,
        uint256 price2,
        uint256 maxDeviation
    ) internal pure returns (bool) {
        if (price1 == 0 || price2 == 0) return false;
        uint256 lowerBound = (price1 * (1e18 - maxDeviation)) / 1e18;
        uint256 upperBound = (price1 * (1e18 + maxDeviation)) / 1e18;
        return price2 >= lowerBound && price2 <= upperBound;
    }

    // claimRefund에서 사용자 누적금액 초기화
    function claimRefund() external nonReentrant {
        require(currentState == State.Failed, "Presale not failed");
        uint256 bnbAmount = contributionsBnb[msg.sender];
        uint256 usdtAmount = contributionsUsdt[msg.sender];

        if (bnbAmount > 0) payable(msg.sender).transfer(bnbAmount);
        if (usdtAmount > 0) USDT_TOKEN.safeTransfer(msg.sender, usdtAmount);

        // 사용자 데이터 초기화
        userTotalContributions[msg.sender] = 0;
        contributionsBnb[msg.sender] = 0;
        contributionsUsdt[msg.sender] = 0;
        lockedUsdValue[msg.sender] = 0;

        emit ClaimRefund(msg.sender, bnbAmount + usdtAmount);
    }

    // 나머지 함수 (이전과 동일)
    function claimTokens() external nonReentrant {
        require(currentState == State.Succeeded, "Presale not succeeded");
        uint256 userUsdValue = lockedUsdValue[msg.sender];
        require(userUsdValue > 0, "No contribution");

        uint256 hbitAmount = (userUsdValue * 1e18) / HBIT_PRICE_USD;
        require(HBIT_TOKEN.balanceOf(address(this)) >= hbitAmount, "Insufficient HBIT balance");
        HBIT_TOKEN.safeTransfer(msg.sender, hbitAmount);
        emit ClaimTokens(msg.sender, hbitAmount);
    }

    function withdrawFunds(
        address payable _recipient,
        uint256 _maxBnb,
        uint256 _maxUsdt
    ) external onlyOwner nonReentrant {
        require(currentState == State.Succeeded, "Presale not succeeded");
        require(_recipient != address(0), "Zero address");

        uint256 bnbAmount = _maxBnb > 0
            ? (_maxBnb < address(this).balance ? _maxBnb : address(this).balance)
            : address(this).balance;
        uint256 usdtAmount = _maxUsdt > 0
            ? (_maxUsdt < USDT_TOKEN.balanceOf(address(this)) ? _maxUsdt : USDT_TOKEN.balanceOf(address(this)))
            : USDT_TOKEN.balanceOf(address(this));

        if (bnbAmount > 0) payable(_recipient).transfer(bnbAmount);
        if (usdtAmount > 0) USDT_TOKEN.safeTransfer(_recipient, usdtAmount);

        emit Withdraw(_recipient, bnbAmount, usdtAmount);
    }

    function depositHbitForSale(uint256 amount) external onlyOwner {
        require(amount > 0, "Amount must be > 0");
        require(hbitDeposited + amount * 1e18 <= TOTAL_HBIT_FOR_SALE, "Would exceed max HBIT supply");
        HBIT_TOKEN.safeTransferFrom(msg.sender, address(this), amount * 1e18);
        hbitDeposited += amount * 1e18;
        emit HBITDeposited(msg.sender, amount * 1e18);
    }

    function getPresaleStatus() external view returns (
        State state,
        uint256 totalRaised,
        uint256 hardCap,
        uint256 softCap,
        bool isSoftCapReached,
        bool isHardCapReached,
        bool isSalePeriodActive,
        uint256 hbitAvailable
    ) {
        return (
            currentState,
            totalUsdRaised,
            HARD_CAP_USD,
            SOFT_CAP_USD,
            totalUsdRaised >= SOFT_CAP_USD,
            totalUsdRaised >= HARD_CAP_USD,
            block.timestamp >= SALE_START_TIME && block.timestamp <= SALE_END_TIME,
            TOTAL_HBIT_FOR_SALE - hbitDeposited
        );
    }

    // 사용자별 구매 정보 조회 함수
    function getUserPurchaseInfo(address user) external view returns (
        uint256 totalContributed,
        uint256 remainingAllowance
    ) {
        return (
            userTotalContributions[user],
            MAX_PURCHASE_PER_USER - userTotalContributions[user]
        );
    }

    // ✅ 추가: Band 심볼 조회 함수 (bytes32 → string 변환)
    function getBandBaseSymbol() external view returns (string memory) {
        return string(abi.encodePacked(BAND_BASE_SYMBOL));
    }

    function getBandQuoteSymbol() external view returns (string memory) {
        return string(abi.encodePacked(BAND_QUOTE_SYMBOL));
    }
}
